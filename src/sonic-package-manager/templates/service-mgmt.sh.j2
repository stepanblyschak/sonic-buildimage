#!/bin/bash

#
# =============== Managed by SONiC Package Manager. DO NOT EDIT! ===============
# generated from /usr/share/sonic/templates/service-mgmt.sh.j2 using sonic-package-manager
#

SERVICE="{{ service_name }}"
PEER="{{ peer_service_name | default('') }}"

if [[ -f /etc/sonic/${SERVICE}_dependent ]]; then
    DEPENDENT="$(cat /etc/sonic/${SERVICE}_dependent)"
else
    DEPENDENT=""
fi

if [[ -f /etc/sonic/${SERVICE}_multi_inst_dependent ]]; then
    MULTI_INST_DEPENDENT="cat /etc/sonic/${SERVICE}_multi_inst_dependent"
else
    MULTI_INST_DEPENDENT=""
fi

if [[ ! -z $DEV ]]; then
    DEBUGLOG="/tmp/$SERVICE_$DEV.log"
else
    DEBUGLOG="/tmp/$SERVICE.log"
fi

if [[ ! -z $PEER ]]; then
    LOCKFILE="/tmp/$SERVICE-$PEER-lock$DEV"
else
    LOCKFILE="/tmp/$SERVICE-lock$DEV"
fi

NAMESPACE_PREFIX="asic"

function debug()
{
    /usr/bin/logger $1
    /bin/echo `date` "- $1" >> ${DEBUGLOG}
}

function lock_service_state_change()
{
    debug "Locking ${LOCKFILE} from ${SERVICE}$DEV service"

    exec {LOCKFD}>${LOCKFILE}
    /usr/bin/flock -x ${LOCKFD}
    trap "/usr/bin/flock -u ${LOCKFD}" 0 2 3 15

    debug "Locked ${LOCKFILE} (${LOCKFD}) from ${SERVICE}$DEV service"
}

function unlock_service_state_change()
{
    debug "Unlocking ${LOCKFILE} (${LOCKFD}) from ${SERVICE}$DEV service"
    /usr/bin/flock -u ${LOCKFD}
}

function check_warm_boot()
{
    SYSTEM_WARM_START=`$SONIC_DB_CLI STATE_DB hget "WARM_RESTART_ENABLE_TABLE|system" enable`
    SERVICE_WARM_START=`$SONIC_DB_CLI STATE_DB hget "WARM_RESTART_ENABLE_TABLE|${SERVICE}" enable`
    if [[ x"$SYSTEM_WARM_START" == x"true" ]] || [[ x"$SERVICE_WARM_START" == x"true" ]]; then
        WARM_BOOT="true"
        validate_restore_count
    else
        WARM_BOOT="false"
    fi
}

function check_fast_boot()
{
    if [[ $($SONIC_DB_CLI STATE_DB GET "FAST_REBOOT|system") == "1" ]]; then
        FAST_BOOT="true"
    else
        FAST_BOOT="false"
    fi
}

function getBootType()
{
    # same code snippet in files/build_templates/docker_image_ctl.j2
    case "$(cat /proc/cmdline)" in
    *SONIC_BOOT_TYPE=warm*)
        TYPE='warm'
        ;;
    *SONIC_BOOT_TYPE=fastfast*)
        TYPE='fastfast'
        ;;
    *SONIC_BOOT_TYPE=fast*|*fast-reboot*)
        # check that the key exists
        if [[ $($SONIC_DB_CLI STATE_DB GET "FAST_REBOOT|system") == "1" ]]; then
            TYPE='fast'
        else
            TYPE='cold'
        fi
        ;;
    *)
        TYPE='cold'
    esac
    echo "${TYPE}"
}

function validate_restore_count()
{
    if [[ x"$WARM_BOOT" == x"true" ]]; then
{%- if service_name == "swss" %}
        RESTORE_COUNT=`$SONIC_DB_CLI STATE_DB hget "WARM_RESTART_TABLE|orchagent" restore_count`
        # We have to make sure db data has not been flushed.
        if [[ -z "$RESTORE_COUNT" ]]; then
            WARM_BOOT="false"
        fi
{%- elif service_name == "bgp" %}
        RESTORE_COUNT=`$SONIC_DB_CLI STATE_DB hget "WARM_RESTART_TABLE|bgp" restore_count`
        # We have to make sure db data has not been flushed.
        if [[ -z "$RESTORE_COUNT" ]]; then
            WARM_BOOT="false"
        fi
{%- else %}
	:
{%- endif %}
    fi
}

# This function cleans up the tables with specific prefixes from the database
# $1 the index of the database
# $2 the string of a list of table prefixes
function clean_up_tables()
{
    $SONIC_DB_CLI $1 EVAL "
    local tables = {$2}
    for i = 1, table.getn(tables) do
        local matches = redis.call('KEYS', tables[i])
        for j,name in ipairs(matches) do
            redis.call('DEL', name)
        end
    end" 0
}

start_peer_and_dependent_services() {
    if [[ x"$WARM_BOOT" != x"true" ]]; then
        if [[ ! -z $PEER ]]; then
            if [[ ! -z $DEV ]]; then
                /bin/systemctl start ${PEER}@$DEV
            else
                /bin/systemctl start ${PEER}
            fi
        fi
        for dep in ${DEPENDENT}; do
            /bin/systemctl start ${dep}
        done
        for dep in ${MULTI_INST_DEPENDENT}; do
            if [[ ! -z $DEV ]]; then
                /bin/systemctl start ${dep}@$DEV
            else
                /bin/systemctl start ${dep}
            fi
        done
    fi
}

stop_peer_and_dependent_services() {
    # if warm/fast start enabled or peer lock exists, don't stop peer service docker
    if [[ x"$WARM_BOOT" != x"true" ]] && [[ x"$FAST_BOOT" != x"true" ]]; then
        if [[ ! -z $PEER ]]; then
            if [[ ! -z $DEV ]]; then
                /bin/systemctl stop ${PEER}@$DEV
            else
                /bin/systemctl stop ${PEER}
            fi
        fi
        for dep in ${DEPENDENT}; do
            /bin/systemctl stop ${dep}
        done
        for dep in ${MULTI_INST_DEPENDENT}; do
            if [[ ! -z $DEV ]]; then
                /bin/systemctl stop ${dep}@$DEV
            else
                /bin/systemctl stop ${dep}
            fi
        done

    fi
}

start() {
    debug "Starting ${SERVICE}$DEV service..."

    if [[ ! -z $PEER ]]; then
        lock_service_state_change
    fi

{% if service_name == "swss" %}
    # Don't flush DB during warm boot
    if [[ x"$WARM_BOOT" != x"true" ]]; then
        debug "Flushing APP, ASIC, COUNTER, CONFIG, and partial STATE databases ..."
        $SONIC_DB_CLI APPL_DB FLUSHDB
        $SONIC_DB_CLI ASIC_DB FLUSHDB
        $SONIC_DB_CLI COUNTERS_DB FLUSHDB
        $SONIC_DB_CLI FLEX_COUNTER_DB FLUSHDB
        clean_up_tables STATE_DB "'PORT_TABLE*', 'MGMT_PORT_TABLE*', 'VLAN_TABLE*', 'VLAN_MEMBER_TABLE*', 'LAG_TABLE*', 'LAG_MEMBER_TABLE*', 'INTERFACE_TABLE*', 'MIRROR_SESSION*', 'VRF_TABLE*', 'FDB_TABLE*'"
    fi
{% elif service_name == "syncd" %}
    if [[ x"$WARM_BOOT" == x"true" ]]; then
        # Leave a mark for syncd scripts running inside docker.
        touch /host/warmboot/warm-starting
    else
        rm -f /host/warmboot/warm-starting
    fi

    # platform specific tasks

    # start mellanox drivers regardless of
    # boot type
    if [[ x"$sonic_asic_platform" == x"mellanox" ]]; then
        BOOT_TYPE=`getBootType`
        if [[ x"$WARM_BOOT" == x"true" || x"$BOOT_TYPE" == x"fast" ]]; then
            export FAST_BOOT=1
        fi

        if [[ x"$WARM_BOOT" != x"true" ]]; then
            if [[ x"$(/bin/systemctl is-active pmon)" == x"active" ]]; then
                /bin/systemctl stop pmon
                debug "pmon is active while syncd starting, stop it first"
            fi
        fi

        /usr/bin/mst start --with_i2cdev
        /usr/bin/mlnx-fw-upgrade.sh
        /etc/init.d/sxdkernel start
    fi

    if [[ x"$WARM_BOOT" != x"true" ]]; then
        if [ x$sonic_asic_platform == x'cavium' ]; then
            /etc/init.d/xpnet.sh start
        fi
    fi
{% endif %}

    # start service docker
    /usr/bin/${SERVICE}.sh start $DEV
    debug "Started ${SERVICE}$DEV service..."

    if [[ ! -z $PEER ]]; then
        # Unlock has to happen before reaching out to peer service
        unlock_service_state_change
    fi
}

wait() {
    start_peer_and_dependent_services

    # Allow some time for peer container to start
    # NOTE: This assumes Docker containers share the same names as their
    # corresponding services
    if [[ ! -z $PEER ]]; then
        for SECS in {1..60}; do
            if [[ ! -z $DEV ]]; then
    {% raw %}
                RUNNING=$(docker inspect -f '{{.State.Running}}' ${PEER}$DEV)
    {% endraw %}
            else
    {% raw %}
                RUNNING=$(docker inspect -f '{{.State.Running}}' ${PEER})
    {% endraw %}
            fi
            if [[ x"$RUNNING" == x"true" ]]; then
                break
            else
                sleep 1
            fi
        done
    fi

    if [[ ! -z $PEER ]]; then
        # NOTE: This assumes Docker containers share the same names as their
        # corresponding services
        if [[ ! -z $DEV ]]; then
            /usr/bin/docker-wait-any ${SERVICE}$DEV ${PEER}$DEV
        else
            /usr/bin/docker-wait-any ${SERVICE} ${PEER}
        fi
    else
        if [[ ! -z $DEV ]]; then
            /usr/bin/${SERVICE}.sh wait $DEV
        else
            /usr/bin/${SERVICE}.sh wait
        fi
    fi
}

stop() {
    debug "Stopping ${SERVICE}$DEV service..."

    [[ -f ${LOCKFILE} ]] || /usr/bin/touch ${LOCKFILE}

    if [[ ! -z $PEER ]]; then
        lock_service_state_change
    fi

    # For WARM/FAST boot do not perform service stop
    if [[ x"$WARM_BOOT" != x"true" ]] && [[ x"$FAST_BOOT" != x"true" ]]; then
        /usr/bin/${SERVICE}.sh stop $DEV
        debug "Stopped ${SERVICE}$DEV service..."
    else
{% if service_name == "swss" %}
        debug "Killing Docker swss..."
        /usr/bin/docker kill swss &> /dev/null || debug "Docker swss is not running ($?) ..."
{% elif service_name == "bgp" %}
    # Kill bgpd to start the bgp graceful restart procedure
    if [[ x"$WARM_BOOT" == x"true" ]] || [[ x"$FAST_BOOT" == x"true" ]]; then
        debug "Kill zebra first"
        /usr/bin/docker exec -i bgp pkill -9 zebra || [ $? == 1 ]
        /usr/bin/docker exec -i bgp pkill -9 bgpd || [ $? == 1 ]
    fi
{% elif service_name == "radv" %}
        debug "Killing Docker radv..."
        /usr/bin/docker kill radv &> /dev/null || debug "Docker radv is not running ($?) ..."
{% endif %}
        :
    fi

{% if service_name == "swss" %}
    # Flush FAST_REBOOT table when swss needs to stop. The only
    # time when this would take effect is when fast-reboot
    # encountered error, e.g. syncd crashed. And swss needs to
    # be restarted.
    if [[ x"$FAST_BOOT" != x"true" ]]; then
        debug "Clearing FAST_REBOOT flag..."
        clean_up_tables STATE_DB "'FAST_REBOOT*'"
    fi
{% elif service_name == "syncd" %}
    if [[ x"$WARM_BOOT" == x"true" ]]; then
        TYPE=warm
    else
        TYPE=cold
    fi

    if [[ x$sonic_asic_platform == x"mellanox" ]] && [[ x$TYPE == x"cold" ]]; then
        debug "Stopping pmon service ahead of syncd..."
        /bin/systemctl stop pmon
        debug "Stopped pmon service"
    fi

    if [[ x$sonic_asic_platform != x"mellanox" ]] || [[ x$TYPE != x"cold" ]]; then
        debug "${TYPE} shutdown syncd process ..."
        /usr/bin/docker exec -i syncd$DEV /usr/bin/syncd_request_shutdown --${TYPE}

        # wait until syncd quits gracefully or force syncd to exit after
        # waiting for 20 seconds
        start_in_secs=${SECONDS}
        end_in_secs=${SECONDS}
        timer_threshold=20
        while docker top syncd$DEV | grep -q /usr/bin/syncd \
                && [[ $((end_in_secs - start_in_secs)) -le $timer_threshold ]]; do
            sleep 0.1
            end_in_secs=${SECONDS}
        done

        if [[ $((end_in_secs - start_in_secs)) -gt $timer_threshold ]]; then
            debug "syncd process in container syncd$DEV did not exit gracefully"
        fi

        /usr/bin/docker exec -i syncd$DEV /bin/sync
        debug "Finished ${TYPE} shutdown syncd process ..."
    fi

    /usr/bin/${SERVICE}.sh stop $DEV
    debug "Stopped ${SERVICE}$DEV service..."

    # platform specific tasks

    if [[ x"$WARM_BOOT" != x"true" ]]; then
        if [ x$sonic_asic_platform == x'mellanox' ]; then
            /etc/init.d/sxdkernel stop
            /usr/bin/mst stop
        elif [ x$sonic_asic_platform == x'cavium' ]; then
            /etc/init.d/xpnet.sh stop
            /etc/init.d/xpnet.sh start
        fi
    fi
{% endif %}

    if [[ ! -z $PEER ]]; then
        # Unlock has to happen before reaching out to peer service
        unlock_service_state_change
    fi

    stop_peer_and_dependent_services
}

OP=$1
DEV=$2

if [ "$DEV" ]; then
    NET_NS="$NAMESPACE_PREFIX$DEV" #name of the network namespace
    SONIC_DB_CLI="sonic-db-cli -n $NET_NS"
else
    NET_NS=""
    SONIC_DB_CLI="sonic-db-cli"
fi

check_warm_boot
check_fast_boot

debug "Fast boot flag: ${SERVICE}$DEV ${FAST_BOOT}."
debug "Warm boot flag: ${SERVICE}$DEV ${WARM_BOOT}."

case "$OP" in
    start|wait|stop)
        $1
        ;;
    *)
        echo "Usage: $0 {start|wait|stop}"
        exit 1
        ;;
esac
